C++语言的设计遵循三条基本原则特性：{{c1::封装}}、{{c1::继承}}和{{c1::多态}}。
%
CPU利用重复的机器周期来执行程序中的指令，包括3步：{{c1::取指令}}、{{c1::译码}}和{{c1::执行}}
%
FTP因{{c1::命令与数据分开传输}}具有较高的效率。
其{{c1::控制连接}}与{{c1::数据连接}}生命周期不同。
%
IEEE浮点数存储标准
1. 单精度（余{{c1::127}}码）
    1位符号，{{c1::8}}位指数E，{{c1::23}}位尾数M
    value = {{c1::S * 2 ^ (E - 127) * 1.M}}
2. 双精度（余{{c1::1023}}码）
    1位符号，{{c1::11}}位指数E，{{c1::52}}位尾数M
    value = {{c1::S * 2 ^ (E - 1023) * 1.M}}
%
IPv4地址有{{c1::32}}位
IPv6地址有{{c1::128}}位
%
TCP/IP协议族的分层架构：
5. {{c1::应用层}}
4. {{c1::传输层}}
3. {{c1::网络层}}
2. {{c1::数据链路层}}
1. {{c1::物理层}}
%
TELNET因{{c1::明文传输密码}}而不常用
%
x的补码 = {{c1::-x}} = {{c1::~x + 1}}
计算方式为{{c1:对最右的1的左边按位取反}}
%
{{c1::CPU}}和{{c1::存储器}}之间通过称为总线的三组线路连接:
1. {{c1::数据总线}}，线根数={{c1::计算机字大小}}
2. {{c1::地址总线}}，线根数={{c1::log(存储空间大小)}}
3. {{c1::控制总线}}，线根数={{c1::log(控制命令数)}}
%
{{c1::机器语言}}是计算机唯一识别的语言。所以由{{c1::汇编语言}}或{{c1::高级语言}}编写的源程序需要经过{{c1::编译}}或{{c1::解释}}翻译成{{c1::目标程序}}才能运行。
%
三种整数表示法：
1. {{c1::无符号}}表示法
2. {{c1::符号加绝对值}}表示法
	常用于采样模拟信号如音频
	存在+0和-0
3. {{c1::二进制补码}}表示法
%
中央处理单元CPU三个组成部分：{{c1::算术逻辑单元ALU}}、{{c1::寄存器组}}、{{c1::控制单元}}
%
主存储器与CPU（的寄存器）之间存在{{c1::高速缓冲存储器}}能提升CPU处理速度。
%
主存储器分为数据易失的{{c1::随机存取存储器RAM}}和数据非易失的{{c1::只读存储器ROM}}。名字这么叫但后者存取也是可随机的。
%
二叉搜索树(BST)定义:{{c1:每个节点的关键字值大于左子树中的所有节点的关键字值，而小于右子树中所有节点的关键字值}}。
%
位置化数字系统，如{{c1::十进制系统}}。
非位置化数字系统，如{{c1::罗马数字系统}}。
%
像素编码的两种技术：
1. {{c1::真彩色}}
	即RGB，每像素占{{c1::24}}位。用于{{c1::JPEG}}
2. {{c1::索引色}}
	从1中选一部分并建立索引（通常是{{c1::256}}个索引，每像素只占{{c1::8}}位)。用于{{c1::GIF}}
%
冯·诺伊曼模型指出{{c1::程序应与数据一样存入存储器}}，如{{c1::EDVAC}}。
%
减法转化成加法：x - y = x + {{c1::y的补码}}
%
加减浮点数时先{{c1::对齐小数点}}转化成{{c1::符号加绝对值}}格式整数的加减法。
%
十进制到其他进制的转换：
整数部分{{c1::连除，输出余数}}。
小数部分{{c1::连乘，输出整数}}。
%
因特网中三层网络：
1. {{c1::骨干网/国际ISP}}
2. {{c1::国内或地域性ISP}}
3. {{c1::客户网络}}
%
图灵模型指出计算机是{{c1::可编程的数据处理器}}，如{{c1::ENIAC}}。
%
存储图像的两种技术：
1. {{c1::光栅图}}（位图）
2. {{c1::矢量图}}（几何模型/面向对象图形）
%
定点表示法不能同时保证较高的{{c1::正确度}}和{{c1::精度}}，因此实数使用{{c1::浮点表示法}}。
%
寄存器分为：{{c1::数据寄存器}}、{{c1::程序计数器PC}}和{{c1::指令寄存器IR}}
%
对二叉搜索树(BST)应用中序遍历时，元素以{{c1::升}}序被访问到。
%
对输入输出设备寻址的两种方法：
1. {{c1::I/O独立寻址}}
2. {{c1::I/O存储器映射寻址}}
%
操作系统使用属于{{c1::交换}}范畴的{{c1::请求分页调度}}或{{c1::请求分段调度}}这两种技术或两种技术的结合进行{{c1::多道程序}}的内存管理时，由于程序一部分驻于内存一部分放在硬盘，因此出现了{{c1::虚拟内存}}的概念，其值为{{c1::两部分之和}}。
%
操作系统的演化：
- {{c1::批处理系统}}
- {{c1::分时系统}}
- {{c1::个人系统}}
- {{c1::并行系统}}
- {{c1::分布式系统}}
- {{c1::实时系统}}
%
操作系统至少由内核和{{c1::用户界面}}组成，其中内核的功能有：{{c1::内存管理}}、{{c1::进程管理}}、{{c1::设备管理}}和{{c1::文件管理}}。
%
数据从I/O设备传输到CPU和内存时因为速度不一致可用的三种同步方法：
1. {{c1::程序控制输入/输出}}
2. {{c1::中断控制输入/输出}}
3. {{c1::直接存储器存取(DMA)}}
%
数据压缩方法分为{{c1::无损方法}}和{{c1::有损方法}}两类，前者通常用来压缩{{c1::文本、程序}}，后者多用于{{c1::图像、视频、音频}}的压缩。
%
文件结构分为只能顺序存取的{{c1::顺序文件}}和可随机存取的{{c1::索引文件}}、{{c1::散列文件}}
%
无损压缩方法有：
- {{c1::游程长度编码}}. 连续重复出现的符号用单个符号与出现次数代替;
- {{c1::赫夫曼编码}}. 出现更频繁的字符分配更短的编码;
- {{c1::Lempel Ziv编码}}. 子字符串替换为字典索引+末位字符。
%
有损压缩方法有：
- {{c1:图像：JPEG}}
- {{c1:视频：MPEG}}
- {{c1:音频：MP3}}
%
深度优先遍历二叉树的三种方式：
1. {{c1:前序遍历}}；
2. {{c1:中序遍历}}；
3. {{c1:后序遍历}}。
%
移位运算
1. 逻辑移位（用于{{c1::无符号整数}}）
2. 算术移位（用于{{c1::补码表示的整数}}）
	1. 算术左移
		{{c1::符号位改变}}则发生溢出，运算非法
	2. 算术右移
		运算时{{c1::符号位保持不变}}
%
程序必定是由{{c1::顺序}}、{{c1::判断（选择）}}和{{c1::循环}}这三种结构组成，其他结构都是不必要的。
%
程序是{{c1::硬盘上非活动状态的一组指令}}；
当程序{{c1::被选中执行，到运行结束期间}}称为作业；
{{c1::驻留于内存中运行}}的作业称为进程。
%
程序设计语言翻译过程：源文件 -> {{c1::词法分析器}} -> {{c1::语法分析器}} -> {{c1::语义分析器}} -> {{c1::代码生成器}} -> 目标文件
%
网络:
1. {{c1::局域网(LAN)}}: 互联多个{{c1::主机}}
2. {{c1::广域网(WAN)}}: 互联多个{{c1::连接设备}}，如{{c1::交换机/路由器/调制解调器}}
3. {{c1::互联网络/网际网}}，如{{c1::因特网}}: 互联多个{{c1::网络}}
%
表示文本符号的代码
1. ASCII. 每个符号占{{c1::7}}位；
2. {{c1::Unicode}}. 每个符号占{{c1::32}}位，能表示世上一切符号，包含ASCII；
3. 其他。
%
规范化的浮点表示法：
1. 组成部分
	- {{c1::符号}}S（1位）
	- {{c1::指数}}E（m位）
	- {{c1::尾数}}M（省略整数部分的1）
2. 实际表示实数
	{{c1::S * 2 ^ (E - 2 ^ (m - 1) + 1) * 1.M}}
3. 这样定义的浮点数还无法表示{{c1::0}}，因此定义{{c1::S = E = M = 0时表示0}}
%
计算机三大子系统是：{{c1::中央处理单元CPU}}、{{c1::存储器组}}和{{c1::输入输出子系统}}
%
计算机加电时，ROM中存有的{{c1::自举程序}}将{{c1::操作系统}}装入RAM运行，这一过程称为{{c1::自举过程}}
%
计算机语言可分成4种编程模式：
1. {{c1::过程式（强制性）}}，如{{c2::C}}、{{c2::FORTRAN}}；
2. {{c1::面向对象}}，如{{c2::C++}}、{{c2::C#}}、{{c2::Java}}；
3. {{c1::函数式}}，如{{c2::LISP}}、{{c2::Scheme}}；
4. {{c1::说明式}}，如{{c2::Prolog}}。
%
输入输出设备因为相对CPU和内存速度太慢，需要经过{{c1::输入/输出控制器}}才能接入总线，常用的几种如{{c1::SCSI}}、{{c1::火线}}、{{c1::USB}}、{{c1::HDMI}}
%
进程在被CPU运行时处于{{c1::运行}}状态，接下来可能出现下面三种情况之一：
1. {{c2::需要I/O资源}}，转为{{c1::等待}}状态;
2. {{c2::时间片耗尽}}，转为{{c1::就绪}}状态；
3. {{c2::进程终止}}。
%
进程死锁的必要非充分条件：
1. {{c1::互斥：一个资源只能被一个进程占有}};
2. {{c1::资源占有：一个进程能获取一个在获取其他资源之前无法使用的资源}};
3. {{c1::抢先：操作系统不能临时对资源重新分配}};
4. {{c1::循环等待：所有的进程和资源包含在一个循环里}}。
